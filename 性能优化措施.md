# yudao-ui-admin-vben 项目性能优化措施

本文档针对 yudao-ui-admin-vben（基于 Vben Admin + Element Plus）项目，提出可落地的性能优化措施，旨在提高网页性能、减少内存占用。每个措施均提供具体代码修改示例。

## 一、构建配置优化

### 1.1 代码分割与懒加载

- **现状**：路由已使用 `() => import()` 动态导入，实现按路由懒加载。
- **优化建议**：配置 `rollupOptions.manualChunks` 将大型第三方库拆分为独立 chunk，避免主包过大。
- **具体修改**：
  1. 打开 `apps/web-ele/vite.config.mts`
  2. 在 `defineConfig` 返回对象中添加 `build.rollupOptions`：

  ```typescript
  export default defineConfig(async () => {
    return {
      application: {},
      vite: {
        plugins: [ ... ],
        build: {
          rollupOptions: {
            output: {
              manualChunks: {
                'element-plus': ['element-plus'],
                'vxe-table': ['vxe-table', 'vxe-pc-ui'],
                'tinymce': ['tinymce'],
                'vue-vendor': ['vue', 'vue-router', 'pinia'],
                'vendor-utils': ['dayjs', '@vueuse/core', '@vueuse/integrations'],
              },
            },
          },
        },
        server: { ... },
      },
    };
  });
  ```

  3. 注意：如果已存在 `build.rollupOptions.output`，需合并配置。

### 1.2 压缩与 Tree Shaking

- **现状**：Vite 默认启用 ESBuild 进行压缩，但 `console` 未被移除。
- **优化建议**：生产构建时移除 `console` 和 `debugger`。
- **具体修改**：
  1. 修改 `internal/vite-config/src/config/application.ts` 中的 `esbuild.drop` 配置：

  ```typescript
  esbuild: {
    drop: isBuild
      ? [
          'console',   // 移除 console
          'debugger',
        ]
      : [],
    legalComments: 'none',
  },
  ```

  2. 确保 `sideEffects` 配置正确：在 `package.json` 中添加：

  ```json
  "sideEffects": [
    "*.css",
    "*.scss"
  ]
  ```

### 1.3 预构建优化

- **现状**：Vite 自动预构建依赖。
- **优化建议**：将常用依赖加入 `optimizeDeps.include` 以减少重复编译。
- **具体修改**：
  1. 在 `apps/web-ele/vite.config.mts` 中添加：
  ```typescript
  vite: {
    optimizeDeps: {
      include: [
        'vue',
        'vue-router',
        'pinia',
        'element-plus',
        'dayjs',
        '@vueuse/core',
      ],
    },
    // ... 其他配置
  }
  ```

## 二、第三方库按需加载

### 2.1 Element Plus

- **现状**：已使用 `unplugin-element-plus` 插件，组件通过异步组件按需导入。
- **优化建议**：确保样式也按需导入，检查是否有全局注册的组件，改为局部注册。
- **具体修改**：
  1. 确认 `unplugin-element-plus` 配置正确（已在 `vite.config.mts` 中）：

  ```typescript
  import ElementPlus from 'unplugin-element-plus/vite';
  // ...
  plugins: [
    ElementPlus({
      format: 'esm',
    }),
  ],
  ```

  2. 检查组件导入方式：在 `apps/web-ele/src/adapter/component/index.ts` 中，组件已使用 `defineAsyncComponent` 异步导入，无需修改。
  3. 避免全局注册：确保没有在 `main.ts` 或 `bootstrap.ts` 中使用 `app.use(ElementPlus)`。

### 2.2 Vxe-Table

- **现状**：已启用 `vxeTableLazyImport` 插件，实现懒加载。
- **优化建议**：确认懒加载配置生效。
- **具体修改**：
  1. 检查 `internal/vite-config/src/plugins/vxe-table.ts` 插件是否启用（默认 `vxeTableLazyImport: true`）。
  2. 在需要使用 Vxe-Table 的页面，确保按需导入：
  ```typescript
  import { VxeGrid, VxeColumn } from 'vxe-table';
  // 或使用异步组件
  const VxeGrid = defineAsyncComponent(() => import('vxe-table/es/grid'));
  ```

### 2.3 其他大型库

- **Tinymce**：使用异步加载，仅在富文本编辑器页面加载。
- **具体修改**：
  1. 检查 `apps/web-ele/src/components/tinymce/editor.vue` 是否已动态导入 Tinymce：

  ```typescript
  import { loadTinymce } from './util';
  // 在 mounted 中加载
  onMounted(() => {
    loadTinymce().then(() => { ... });
  });
  ```

  2. **Video.js**、**Cropper.js** 等：确保在组件中动态导入：

  ```typescript
  const Cropper = defineAsyncComponent(() => import('cropperjs'));
  ```

## 三、路由与代码分割

### 3.1 路由懒加载

- **现状**：路由配置已使用动态导入。
- **优化建议**：对于嵌套路由，确保子组件也使用懒加载；使用 `webpackChunkName` 注释命名 chunk。
- **具体修改**：
  1. 检查嵌套路由配置（如 `apps/web-ele/src/router/routes/modules/` 中的路由），确保子组件也使用 `() => import()`。
  2. 为路由添加 chunk 名称，便于调试和预加载：

  ```typescript
  // 示例：在路由配置中添加注释
  component: () => import(/* webpackChunkName: "dashboard" */ '#/views/dashboard/analytics/index.vue'),
  ```

  3. Vite 支持该注释，会生成对应的 chunk 文件名为 `dashboard-[hash].js`。

### 3.2 预加载与预取

- **现状**：未配置预加载。
- **优化建议**：对核心路由添加预加载，使用 `vite-plugin-preload` 自动注入。
- **具体修改**：
  1. 安装插件：

  ```bash
  pnpm add -D vite-plugin-preload
  ```

  2. 在 `apps/web-ele/vite.config.mts` 中配置：

  ```typescript
  import Preload from 'vite-plugin-preload';
  // ...
  plugins: [
    // ... 其他插件
    Preload({
      include: ['dashboard', 'login'], // 指定需要预加载的 chunk 名称
    }),
  ],
  ```

  3. 或者手动在 `index.html` 中添加预加载标签：

  ```html
  <link
    rel="preload"
    href="/src/views/dashboard/analytics/index.vue"
    as="script"
  />
  ```

## 四、内存泄漏与组件卸载

### 4.1 事件监听器清理

- **现状**：部分组件使用了 `onBeforeUnmount` 清理定时器和事件。
- **优化建议**：全局检查 `addEventListener`、`setInterval`、`setTimeout` 等，确保在 `onUnmounted` 中清理；使用 `@vueuse/core` 的组合式函数自动清理。
- **具体修改**：
  1. 搜索项目中的 `addEventListener`（如 `apps/web-ele/src/views/mall/promotion/components/diy-editor/components/mobile/hot-zone/components/hot-zone-edit-dialog/controller.ts`），确保有对应的 `removeEventListener`。
  2. 使用 `@vueuse/core` 替代手动监听：

  ```typescript
  import { useEventListener, useInterval } from '@vueuse/core';
  // 事件监听，自动清理
  useEventListener(window, 'resize', handleResize);
  // 定时器，自动清理
  const { pause } = useInterval(1000, { immediate: true });
  ```

  3. 在组件中统一添加清理逻辑：

  ```typescript
  import { onUnmounted } from 'vue';
  onUnmounted(() => {
    // 清理事件、定时器、订阅等
  });
  ```

### 4.2 Vue 组件实例泄漏

- **现状**：可能存在未销毁的组件实例（如 keep-alive 缓存过多）。
- **优化建议**：合理使用 `<keep-alive>` 的 `include`/`exclude` 属性，避免缓存过多页面。
- **具体修改**：
  1. 检查 `apps/web-ele/src/app.vue` 或布局组件中的 `<keep-alive>` 使用。
  2. 添加 `include` 属性限制缓存页面：

  ```vue
  <router-view v-slot="{ Component }">
    <keep-alive :include="['Dashboard', 'UserList']">
      <component :is="Component" />
    </keep-alive>
  </router-view>
  ```

  3. 在路由守卫中动态清除缓存（使用 `$store` 或全局变量记录）。

### 4.3 大型数据对象释放

- **现状**：Store 中可能缓存大量数据。
- **优化建议**：在页面离开时清理 Store 中的临时数据；使用 `pinia` 的 `$dispose` 手动清理不再需要的 store。
- **具体修改**：
  1. 在 Pinia store 中定义清理方法：

  ```typescript
  // stores/useSomeStore.ts
  export const useSomeStore = defineStore('some', {
    state: () => ({ largeData: null }),
    actions: {
      clearLargeData() {
        this.largeData = null;
      },
    },
  });
  ```

  2. 在页面组件卸载时调用：

  ```typescript
  import { useSomeStore } from '@/stores';
  onUnmounted(() => {
    useSomeStore().clearLargeData();
  });
  ```

  3. 对于不再需要的 store，可以调用 `$dispose()`（谨慎使用）：

  ```typescript
  const store = useSomeStore();
  store.$dispose();
  ```

## 五、图片与资源优化

### 5.1 图片压缩

- **现状**：项目内图片较少，未进行压缩。
- **优化建议**：使用构建工具自动压缩 PNG、JPEG、SVG；将图片转换为 WebP 格式。
- **具体修改**：
  1. 安装 `vite-plugin-imagemin`：

  ```bash
  pnpm add -D vite-plugin-imagemin
  ```

  2. 在 `apps/web-ele/vite.config.mts` 中配置：

  ```typescript
  import { imagemin } from 'vite-plugin-imagemin';
  // ...
  plugins: [
    imagemin({
      gifsicle: { optimizationLevel: 7, interlaced: false },
      mozjpeg: { quality: 80 },
      pngquant: { quality: [0.8, 0.9] },
      svgo: {
        plugins: [
          { name: 'removeViewBox' },
          { name: 'removeEmptyAttrs', active: false },
        ],
      },
    }),
  ],
  ```

  3. 对于 WebP 转换，可以使用 `sharp` 在构建时转换，或使用 CDN 服务。

### 5.2 图片懒加载

- **现状**：未使用图片懒加载。
- **优化建议**：为 `<img>` 添加 `loading="lazy"` 属性；对于背景图使用 `Intersection Observer`。
- **具体修改**：
  1. 在模板中为所有 `<img>` 添加 `loading="lazy"`：

  ```vue
  <img src="image.jpg" alt="..." loading="lazy" />
  ```

  2. 对于背景图懒加载，可以使用 `@vueuse/core` 的 `useIntersectionObserver`：

  ```vue
  <script setup>
  import { useIntersectionObserver } from '@vueuse/core';
  const target = ref(null);
  const isVisible = ref(false);
  useIntersectionObserver(target, ([{ isIntersecting }]) => {
    if (isIntersecting) {
      isVisible.value = true;
    }
  });
  </script>
  <template>
    <div
      ref="target"
      :style="{ backgroundImage: isVisible ? 'url(image.jpg)' : '' }"
    ></div>
  </template>
  ```

### 5.3 字体与图标优化

- **现状**：使用 Iconify 图标，按需加载。
- **优化建议**：将常用图标打包为雪碧图或内联 SVG；使用 `font-display: swap`。
- **具体修改**：
  1. 内联常用 SVG 图标：在 `assets/icons` 中存放 SVG 文件，使用 `vite-svg-loader` 导入为组件。
  2. 安装 `vite-svg-loader`：

  ```bash
  pnpm add -D vite-svg-loader
  ```

  3. 在 `vite.config.mts` 中添加：

  ```typescript
  import svgLoader from 'vite-svg-loader';
  plugins: [svgLoader()],
  ```

  4. 在 CSS 中设置字体显示策略：

  ```css
  @font-face {
    font-family: 'CustomFont';
    src: url('/fonts/custom.woff2') format('woff2');
    font-display: swap;
  }
  ```

## 六、缓存策略

### 6.1 HTTP 缓存

- **现状**：依赖后端或 CDN 配置。
- **优化建议**：配置静态资源长期缓存；使用内容哈希实现缓存失效。
- **具体修改**：
  1. 在 Nginx 配置中添加（示例）：

  ```nginx
  location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$ {
    expires 1y;
    add_header Cache-Control "public, immutable";
  }
  ```

  2. Vite 已为资源添加哈希，确保构建后文件名带哈希，如 `app-abc123.js`。
  3. 在 `vite.config.mts` 中确认 `build.rollupOptions.output` 已配置哈希：

  ```typescript
  output: {
    assetFileNames: '[ext]/[name]-[hash].[ext]',
    chunkFileNames: 'js/[name]-[hash].js',
    entryFileNames: 'jse/index-[name]-[hash].js',
  },
  ```

### 6.2 Service Worker（PWA）

- **现状**：已启用 PWA 插件，但缓存策略可能未优化。
- **优化建议**：配置 `workbox` 策略，对 API 请求使用 NetworkFirst，对静态资源使用 CacheFirst。
- **具体修改**：
  1. 检查 `internal/vite-config/src/options.ts` 中的 `getDefaultPwaOptions`，可扩展 `workbox` 配置。
  2. 在 `apps/web-ele/vite.config.mts` 中自定义 PWA 选项：
  ```typescript
  import { VitePWA } from 'vite-plugin-pwa';
  // ...
  plugins: [
    VitePWA({
      workbox: {
        globPatterns: ['**/*.{js,css,html,ico,png,svg,woff2}'],
        runtimeCaching: [
          {
            urlPattern: /^https:\/\/api\.example\.com\/.*/i,
            handler: 'NetworkFirst',
            options: {
              cacheName: 'api-cache',
              expiration: {
                maxEntries: 10,
                maxAgeSeconds: 60 * 60 * 24,
              },
            },
          },
          {
            urlPattern: /\.(?:js|css|woff2)$/,
            handler: 'CacheFirst',
            options: {
              cacheName: 'static-resources',
            },
          },
        ],
      },
    }),
  ],
  ```

### 6.3 本地存储优化

- **现状**：使用 localStorage 存储 token、用户信息等。
- **优化建议**：避免存储过大对象，定期清理过期数据；使用 `sessionStorage` 替代临时数据。
- **具体修改**：
  1. 封装存储工具，添加过期时间：

  ```typescript
  // utils/storage.ts
  export const setWithExpiry = (key: string, value: any, ttl: number) => {
    const item = {
      value,
      expiry: Date.now() + ttl,
    };
    localStorage.setItem(key, JSON.stringify(item));
  };
  export const getWithExpiry = (key: string) => {
    const itemStr = localStorage.getItem(key);
    if (!itemStr) return null;
    const item = JSON.parse(itemStr);
    if (Date.now() > item.expiry) {
      localStorage.removeItem(key);
      return null;
    }
    return item.value;
  };
  ```

  2. 对于临时数据（如表单草稿），使用 `sessionStorage`：

  ```typescript
  sessionStorage.setItem('draft', JSON.stringify(data));
  ```

## 七、监控与性能测量

### 7.1 性能指标监控

- **现状**：未集成前端性能监控。
- **优化建议**：集成 `web-vitals` 库，测量 LCP、FID、CLS 等核心 Web 指标，并将数据上报。
- **具体修改**：
  1. 安装 `web-vitals`：

  ```bash
  pnpm add web-vitals
  ```

  2. 在 `apps/web-ele/src/bootstrap.ts` 或单独模块中初始化：

  ```typescript
  import { onCLS, onFID, onLCP } from 'web-vitals';
  onCLS(console.log);
  onFID(console.log);
  onLCP(console.log);
  // 上报到后端
  const reportWebVitals = (metric: any) => {
    fetch('/api/web-vitals', {
      method: 'POST',
      body: JSON.stringify(metric),
      headers: { 'Content-Type': 'application/json' },
    });
  };
  onCLS(reportWebVitals);
  onFID(reportWebVitals);
  onLCP(reportWebVitals);
  ```

### 7.2 错误监控

- **现状**：未集成前端错误监控。
- **优化建议**：集成 Sentry 或类似工具，捕获 JavaScript 错误、Promise 异常、资源加载失败。
- **具体修改**：
  1. 安装 Sentry：

  ```bash
  pnpm add @sentry/vue @sentry/tracing
  ```

  2. 在 `apps/web-ele/src/bootstrap.ts` 中初始化：

  ```typescript
  import * as Sentry from '@sentry/vue';
  import { Integrations } from '@sentry/tracing';
  Sentry.init({
    app, // Vue app 实例
    dsn: 'YOUR_DSN',
    integrations: [
      new Integrations.BrowserTracing({
        routingInstrumentation: Sentry.vueRouterInstrumentation(router),
      }),
    ],
    tracesSampleRate: 0.1, // 采样率
  });
  ```

  3. 捕获未处理的 Promise 异常：

  ```typescript
  window.addEventListener('unhandledrejection', (event) => {
    Sentry.captureException(event.reason);
  });
  ```

### 7.3 内存监控

- **现状**：未监控内存使用情况。
- **优化建议**：在开发阶段使用 Chrome DevTools Memory 面板定期检查内存泄漏；生产环境抽样上报。
- **具体修改**：
  1. 开发阶段：定期使用 Chrome DevTools 的 Memory 面板录制堆快照，对比前后差异。
  2. 生产环境（谨慎使用）：

  ```typescript
  // 仅当 performance.memory 存在时（Chrome 非标准）
  if (performance.memory) {
    const memory = performance.memory;
    console.log(`Used JS Heap: ${memory.usedJSHeapSize / 1024 / 1024} MB`);
    // 可上报
  }
  ```

  3. 使用 `@vueuse/core` 的 `useMemory`（实验性）：

  ```typescript
  import { useMemory } from '@vueuse/core';
  const { isSupported, memory } = useMemory();
  watch(memory, (val) => {
    if (val) console.log('Memory used:', val.usedJSHeapSize);
  });
  ```

## 八、运行时优化

### 8.1 虚拟滚动

- **现状**：大数据列表可能未使用虚拟滚动。
- **优化建议**：对大型表格启用虚拟滚动；使用 `vue-virtual-scroller` 优化长列表。
- **具体修改**：
  1. Vxe-Table 已支持虚拟滚动，在列配置中启用：

  ```typescript
  const gridOptions = ref({
    height: 600,
    virtualScroll: true,
  });
  ```

  2. 对于自定义列表，安装 `vue-virtual-scroller`：

  ```bash
  pnpm add vue-virtual-scroller
  ```

  3. 在组件中使用：

  ```vue
  <template>
    <RecycleScroller :items="list" :item-size="50" key-field="id">
      <template #default="{ item }">
        <div>{{ item.name }}</div>
      </template>
    </RecycleScroller>
  </template>
  <script setup>
  import { RecycleScroller } from 'vue-virtual-scroller';
  import 'vue-virtual-scroller/dist/vue-virtual-scroller.css';
  </script>
  ```

### 8.2 防抖与节流

- **现状**：部分搜索框、窗口 resize 可能未做防抖。
- **优化建议**：对频繁触发的事件使用防抖/节流。
- **具体修改**：
  1. 使用 `@vueuse/core` 的 `useDebounceFn` 和 `useThrottleFn`：

  ```typescript
  import { useDebounceFn, useThrottleFn } from '@vueuse/core';
  const search = ref('');
  const debouncedSearch = useDebounceFn((value) => {
    // 执行搜索
  }, 500);
  watch(search, debouncedSearch);
  ```

  2. 窗口 resize 节流：

  ```typescript
  import { useEventListener } from '@vueuse/core';
  const handleResize = useThrottleFn(() => {
    console.log(window.innerWidth);
  }, 200);
  useEventListener(window, 'resize', handleResize);
  ```

### 8.3 计算属性缓存

- **现状**：可能存在重复计算。
- **优化建议**：审查 `computed` 属性，确保依赖项稳定；谨慎使用 `watch` 的 `immediate`、`deep`。
- **具体修改**：
  1. 检查组件中的 `computed`，避免在计算属性内执行昂贵操作：

  ```typescript
  // 不好：每次访问都执行 filter
  const filteredList = computed(() => {
    return hugeList.value.filter((item) => item.active);
  });
  // 优化：使用 memoization 或仅在依赖变化时计算
  const activeList = ref([]);
  watch(
    hugeList,
    (list) => {
      activeList.value = list.filter((item) => item.active);
    },
    { immediate: true },
  );
  ```

  2. 避免不必要的 `deep` watch：

  ```typescript
  // 如果只需要检测引用变化，不要用 deep
  watch(someObject, () => { ... }, { deep: false });
  ```

## 九、构建分析与持续优化

### 9.1 构建分析

- **现状**：支持 `build:analyze` 命令。
- **优化建议**：定期运行分析，检查包体积变化；使用 `rollup-plugin-visualizer` 生成可视化报告。
- **具体修改**：
  1. 安装 `rollup-plugin-visualizer`：

  ```bash
  pnpm add -D rollup-plugin-visualizer
  ```

  2. 在 `apps/web-ele/vite.config.mts` 中配置：

  ```typescript
  import { visualizer } from 'rollup-plugin-visualizer';
  // ...
  plugins: [
    // ... 其他插件
    visualizer({
      filename: 'dist/stats.html',
      open: false,
      gzipSize: true,
      brotliSize: true,
    }),
  ],
  ```

  3. 运行分析构建：

  ```bash
  pnpm run build:analyze
  ```

  4. 查看生成的 `dist/stats.html` 文件，分析模块体积。

### 9.2 持续集成优化

- **现状**：未在 CI 中集成性能检查。
- **优化建议**：在 CI 中添加 Lighthouse CI，设定性能预算；对 PR 进行包体积变化检查。
- **具体修改**：
  1. 安装 Lighthouse CI：

  ```bash
  pnpm add -D @lhci/cli
  ```

  2. 创建 `.lighthouserc.js` 配置文件：

  ```javascript
  module.exports = {
    ci: {
      collect: {
        staticDistDir: './dist',
        url: ['http://localhost:4173'],
      },
      assert: {
        assertions: {
          'categories:performance': ['error', { minScore: 0.8 }],
          'categories:accessibility': ['error', { minScore: 0.9 }],
        },
      },
      upload: {
        target: 'temporary-public-storage',
      },
    },
  };
  ```

  3. 在 CI 脚本中添加：

  ```yaml
  # .github/workflows/ci.yml
  - name: Lighthouse CI
    run: lhci autorun
  ```

  4. 使用 `size-limit` 检查包体积：

  ```bash
  pnpm add -D size-limit @size-limit/preset-app
  ```

  5. 配置 `.size-limit.json`：

  ```json
  [
    {
      "path": "dist/assets/*.js",
      "limit": "500 kB"
    }
  ]
  ```

## 十、推荐工具与插件

1. **Vite 插件**：
   - `vite-plugin-compression`：生成 gzip/brotli 压缩文件。
   - `vite-plugin-imagemin`：图片压缩。
   - `vite-plugin-preload`：资源预加载。
   - `vite-plugin-pwa`：PWA 支持（已集成）。
   - `rollup-plugin-visualizer`：构建分析。

2. **Vue 工具**：
   - `@vueuse/core`：组合式工具集，包含性能相关函数。
   - `vue-virtual-scroller`：虚拟滚动。
   - `pinia`：状态管理（已集成）。

3. **监控工具**：
   - `web-vitals`：核心 Web 指标测量。
   - `@sentry/vue`：错误监控。
   - `lighthouse-ci`：持续性能检查。

## 总结

以上措施按优先级排序，建议从构建配置、第三方库按需加载、内存泄漏检查等容易落地且效果明显的方面开始实施。每项优化后应通过 Lighthouse 评分、包体积变化、内存占用等指标验证效果。

**立即行动项**：

1. 配置 `manualChunks` 分割 vendor（修改 `vite.config.mts`）。
2. 启用 `console` 移除（修改 `application.ts`）。
3. 检查并添加图片懒加载（为 `<img>` 添加 `loading="lazy"`）。
4. 集成 `web-vitals` 监控（安装并初始化）。

**长期维护**：

- 定期进行性能审计（使用 Lighthouse CI）。
- 保持依赖更新，利用新版本性能改进。
- 建立性能文化，在开发流程中加入性能检查（如 PR 体积检查）。
